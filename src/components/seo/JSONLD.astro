---
/**
 * JSON-LD Component
 *
 * Identity-first structured data for search engines:
 * - ProfilePage: Entity Home for Person (About page only)
 * - WebSite: Site metadata with author reference (Home page)
 * - WebPage: Generic page with author reference (e.g., Uses)
 * - Blog: Blog metadata with publisher reference (Blog index)
 * - BlogPosting: Article with author reference (Blog posts)
 */

import {SITE} from "../../config";
import type {
  JSONLDArticleData,
  JSONLDBlog,
  JSONLDBlogPosting,
  JSONLDProfilePage,
  JSONLDRef,
  JSONLDType,
  JSONLDWebPage,
  JSONLDWebSite,
} from "../../types";

/**
 * Page data for WebPage schema type.
 */
interface PageData {
  /**
   * Page name/title.
   */
  name: string;

  /**
   * Page description.
   */
  description: string;
}

/**
 * Props for the JSONLD component.
 */
interface Props {
  /**
   * Schema type to render.
   */
  type: JSONLDType;

  /**
   * Article data for BlogPosting schema type.
   */
  article?: JSONLDArticleData;

  /**
   * Page data for WebPage schema type.
   */
  page?: PageData;
}

const {type, article, page} = Astro.props;

// Canonical URL for this page
const pageUrl = new URL(Astro.url.pathname, Astro.site ?? SITE.url).href;

// Reference to Person entity (defined on /about)
const personRef: JSONLDRef = {"@id": SITE.entityIds.person};

/**
 * Build the appropriate schema based on type.
 */
const buildSchema = ():
  | JSONLDProfilePage
  | JSONLDWebSite
  | JSONLDWebPage
  | JSONLDBlog
  | JSONLDBlogPosting => {
  switch (type) {
    case "ProfilePage":
      // Entity Home: full Person definition
      return {
        "@context": "https://schema.org",
        "@type": "ProfilePage",
        "@id": `${SITE.url}/about/#profilepage`,
        url: `${SITE.url}/about`,
        name: `About | ${SITE.author.name}`,
        mainEntity: {
          "@type": "Person",
          "@id": SITE.entityIds.person,
          name: SITE.author.name,
          url: SITE.url,
          jobTitle: SITE.author.jobTitle,
          description: SITE.description,
          worksFor: {
            "@type": "Organization",
            name: SITE.author.worksFor.name,
            url: SITE.author.worksFor.url,
          },
          address: {
            "@type": "PostalAddress",
            addressLocality: SITE.author.address.locality,
            addressCountry: SITE.author.address.country,
          },
          sameAs: [SITE.author.github, SITE.author.linkedin],
        },
      };

    case "Blog":
      return {
        "@context": "https://schema.org",
        "@type": "Blog",
        "@id": SITE.entityIds.blog,
        url: `${SITE.url}/blog`,
        name: `Blog | ${SITE.author.name}`,
        description:
          "Writing about AI agents, creative coding, and software engineering.",
        publisher: personRef,
      };

    case "BlogPosting":
      if (!article) {
        throw new Error("BlogPosting requires article data");
      }

      return {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        headline: article.headline,
        description: article.description,
        url: pageUrl,
        datePublished: article.publishDate.toISOString(),
        dateModified: (article.updatedDate ?? article.publishDate).toISOString(),
        author: personRef,
        isPartOf: {"@id": SITE.entityIds.blog},
        keywords: article.tags?.join(", "),
      };

    case "WebPage":
      if (!page) {
        throw new Error("WebPage requires page data");
      }

      return {
        "@context": "https://schema.org",
        "@type": "WebPage",
        url: pageUrl,
        name: page.name,
        description: page.description,
        author: personRef,
        isPartOf: {"@id": SITE.entityIds.website},
      };

    case "WebSite":
    default:
      return {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "@id": SITE.entityIds.website,
        name: SITE.name,
        url: SITE.url,
        description: SITE.description,
        author: personRef,
      };
  }
};

const schema = buildSchema();
---

<script
  is:inline
  type="application/ld+json"
  set:html={JSON.stringify(schema)}
/>
